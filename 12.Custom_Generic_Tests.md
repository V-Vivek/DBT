# Custom Generic Tests in dbt

dbt allows you to define **custom generic tests** to validate your data models beyond the built-in tests. Generic tests are reusable and parameterized, making them powerful for enforcing data quality rules across multiple models or columns.

## Why Use Custom Generic Tests?

- Enforce business rules specific to your organization.
- Reuse logic across multiple models or columns.
- Maintain cleaner and DRY (Don't Repeat Yourself) code.

## How to Create a Custom Generic Test

1. **Create a test file** in your `tests` directory, e.g., `tests/not_null_and_positive.sql`.
2. **Define the test logic** using Jinja and SQL.

> You can place your custom generic test file directly in the `tests` directory or within a subdirectory such as `tests/generic/` to better organize your tests.

### Example: Custom Test for Not Null and Positive Values

**File:** `tests/not_null_and_positive.sql`
```jinja
{% test not_null_and_positive(model, column_name) %}
    select *
    from {{ model }}
    where {{ column_name }} is null
       or {{ column_name }} <= 0
{% endtest %}
```
> Note that we have not hard coded the model name or column name unlike singular tests as this is a generic test and can be reused across multiple models and columns
## Using the Custom Test in a Model

In your model's `.yml` file:
```yaml
models:
  - name: orders
    columns:
      - name: order_amount
        tests:
          - not_null_and_positive
```
### Adding Additional Conditions to Custom Tests

You can make your custom test more flexible by allowing additional `where` conditions as parameters.

**Usage in your `.yml` file:**
```yaml
models:
  - name: orders
    columns:
      - name: order_amount
        tests:
          - not_null_and_positive:
              where: "order_status = 'completed'"
```
This will only apply the test to rows where `order_status` is `'completed'`.

## Summary

Custom generic tests in dbt help you enforce complex data quality rules in a reusable way. Define your test logic once and apply it wherever needed!
