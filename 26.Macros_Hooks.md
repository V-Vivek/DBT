# Hook Type Macros in dbt (BigQuery Example)

dbt supports **hooks**, which are SQL statements or macros that run at specific points in the dbt workflow (e.g., before/after a model runs). Hook type macros allow you to encapsulate hook logic in reusable macros.

## Defining a Hook Macro

You can define a hook macro in your `macros/` directory:

```jinja
-- macros/log_start.sql
{% macro log_start(model_name) %}
    insert into `my_project.my_dataset.dbt_logs` (event_time, event_type, model)
    values (current_timestamp(), 'start', '{{ model_name }}')
{% endmacro %}
```

## Using the Hook Macro in a Model

In your model's config, reference the macro using `{{ ... }}`:

```sql
-- models/my_model.sql
{{ 
    config(
        pre_hook="{{ log_start(this.name) }}"
    ) 
}}

select * from `my_project.my_dataset.source_table`
```

## How It Works

- **pre_hook**: Runs before the model SQL executes.
- **post_hook**: Runs after the model SQL executes.
- The macro can use Jinja context variables like `this` or `model`.

## Example: Logging Model Completion

```jinja
-- macros/log_end.sql
{% macro log_end(model_name) %}
    insert into `my_project.my_dataset.dbt_logs` (event_time, event_type, model)
    values (current_timestamp(), 'end', '{{ model_name }}')
{% endmacro %}
```

```sql
{{ 
    config(
        post_hook="{{ log_end(this.name) }}"
    ) 
}}
```

## Summary

- Hook type macros make hooks reusable and maintainable.
- They are especially useful for logging, auditing, or custom notifications in BigQuery projects.
- Use `pre_hook` and `post_hook` in your model configs to call these macros.
